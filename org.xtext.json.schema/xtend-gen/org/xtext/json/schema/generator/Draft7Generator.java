/**
 * generated by Xtext 2.20.0
 */
package org.xtext.json.schema.generator;

import com.google.common.collect.Iterators;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import org.xtext.json.schema.draft7.AbstractSchema;
import org.xtext.json.schema.draft7.NamedSchema;
import org.xtext.json.schema.draft7.Reference;
import org.xtext.json.schema.draft7.Schema;
import org.xtext.json.schema.generator.BuilderGenerator;
import org.xtext.json.schema.generator.CustomModel;
import org.xtext.json.schema.generator.GeneratorUtils;
import org.xtext.json.schema.generator.ModelGenerator;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class Draft7Generator extends AbstractGenerator {
  private Schema root;
  
  private List<CustomModel> objectList;
  
  private ModelGenerator modelGenerator;
  
  private BuilderGenerator builderGenerator;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    ArrayList<CustomModel> _arrayList = new ArrayList<CustomModel>();
    this.objectList = _arrayList;
    ArrayList<String> _arrayList_1 = new ArrayList<String>();
    this.walkedThroughSchemas = _arrayList_1;
    this.root = Iterators.<Schema>filter(resource.getAllContents(), Schema.class).next();
    this.recursiveObjectFinder(this.root, null);
    ModelGenerator _modelGenerator = new ModelGenerator(this.objectList, this.root);
    this.modelGenerator = _modelGenerator;
    BuilderGenerator _builderGenerator = new BuilderGenerator(this.objectList, this.root);
    this.builderGenerator = _builderGenerator;
    final Consumer<CustomModel> _function = (CustomModel model) -> {
      this.modelGenerator.generateModelFile(model, fsa);
      this.builderGenerator.generateBuilderFile(model, fsa);
    };
    this.objectList.forEach(_function);
    System.out.println(this.objectList.size());
  }
  
  private int anonymCounter = 1;
  
  private ArrayList<String> walkedThroughSchemas = new ArrayList<String>();
  
  public void recursiveObjectFinder(final AbstractSchema abstractSchema, final String parentName) {
    if ((abstractSchema == null)) {
      return;
    }
    Schema _xifexpression = null;
    boolean _isSchema = GeneratorUtils.isSchema(abstractSchema);
    if (_isSchema) {
      _xifexpression = ((Schema) abstractSchema);
    } else {
      _xifexpression = GeneratorUtils.findLocalReference(GeneratorUtils.realizeName(((Reference) abstractSchema).getUri()), this.root);
    }
    Schema schema = _xifexpression;
    boolean _isObject = GeneratorUtils.isObject(schema);
    if (_isObject) {
      String objectName = "";
      boolean _isReference = GeneratorUtils.isReference(abstractSchema);
      if (_isReference) {
        objectName = GeneratorUtils.getReferenceName(abstractSchema);
        String _title = schema.getTitle();
        boolean _tripleEquals = (_title == null);
        if (_tripleEquals) {
          schema.setTitle(objectName);
        }
      } else {
        String _title_1 = schema.getTitle();
        boolean _tripleNotEquals = (_title_1 != null);
        if (_tripleNotEquals) {
          objectName = StringExtensions.toFirstUpper(schema.getTitle().replace(" ", ""));
        } else {
          int _plusPlus = this.anonymCounter++;
          String _plus = ("AnonymSchema" + Integer.valueOf(_plusPlus));
          objectName = _plus;
        }
      }
      boolean _contains = this.walkedThroughSchemas.contains(objectName);
      if (_contains) {
        return;
      }
      final CustomModel cm = new CustomModel(schema, objectName);
      cm.setParentName(parentName);
      this.objectList.add(cm);
      this.walkedThroughSchemas.add(objectName);
      if (((schema.getAdditionalProperties() != null) && (schema.getAdditionalProperties().getSchema() != null))) {
        this.recursiveObjectFinder(schema.getAdditionalProperties().getSchema(), objectName);
      }
      EList<NamedSchema> _properties = schema.getProperties();
      boolean _tripleNotEquals_1 = (_properties != null);
      if (_tripleNotEquals_1) {
        EList<NamedSchema> _properties_1 = schema.getProperties();
        for (final NamedSchema property : _properties_1) {
          this.recursiveObjectFinder(property.getSchema(), objectName);
        }
      }
    } else {
      boolean _isArray = GeneratorUtils.isArray(schema);
      if (_isArray) {
        if (((schema.getAdditionalItems() != null) && (schema.getAdditionalItems().getSchema() != null))) {
          this.recursiveObjectFinder(schema.getAdditionalItems().getSchema(), parentName);
        }
        if (((schema.getItems() != null) && (schema.getItems().getItems().size() > 0))) {
          EList<AbstractSchema> _items = schema.getItems().getItems();
          for (final AbstractSchema itemSchema : _items) {
            this.recursiveObjectFinder(itemSchema, parentName);
          }
        }
      }
    }
    EList<AbstractSchema> _allOfs = schema.getAllOfs();
    boolean _tripleNotEquals_2 = (_allOfs != null);
    if (_tripleNotEquals_2) {
      EList<AbstractSchema> _allOfs_1 = schema.getAllOfs();
      for (final AbstractSchema allOf : _allOfs_1) {
        this.recursiveObjectFinder(allOf, parentName);
      }
    }
    EList<AbstractSchema> _anyOfs = schema.getAnyOfs();
    boolean _tripleNotEquals_3 = (_anyOfs != null);
    if (_tripleNotEquals_3) {
      EList<AbstractSchema> _anyOfs_1 = schema.getAnyOfs();
      for (final AbstractSchema anyOf : _anyOfs_1) {
        this.recursiveObjectFinder(anyOf, parentName);
      }
    }
    EList<AbstractSchema> _oneOfs = schema.getOneOfs();
    boolean _tripleNotEquals_4 = (_oneOfs != null);
    if (_tripleNotEquals_4) {
      EList<AbstractSchema> _oneOfs_1 = schema.getOneOfs();
      for (final AbstractSchema oneOf : _oneOfs_1) {
        this.recursiveObjectFinder(oneOf, parentName);
      }
    }
  }
}
