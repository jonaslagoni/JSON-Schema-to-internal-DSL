/*
 * generated by Xtext 2.20.0
 */
package org.xtext.json.schema.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.List
import java.util.ArrayList
import org.eclipse.xtend.lib.annotations.Accessors
import org.xtext.json.schema.draft7.Schema
import org.xtext.json.schema.draft7.AbstractSchema
import org.xtext.json.schema.draft7.AnyString
import org.xtext.json.schema.draft7.JsonTypes
import org.xtext.json.schema.draft7.NamedSchema
import org.eclipse.xtext.naming.IQualifiedNameProvider
import com.google.inject.Inject
import org.xtext.json.schema.draft7.Types
import java.util.Map
import java.util.HashMap
import org.xtext.json.schema.draft7.Reference

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class Draft7Generator extends AbstractGenerator {
	Schema root
	List<CustomModel> objectList
	ModelGenerator modelGenerator
	RootBuilderGenerator rootBuilderGenerator
	BuilderGenerator builderGenerator
	List<String> walkedThroughDefinition
	List<AbstractSchema> currentNestedSchemas
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		objectList = new ArrayList()
		walkedThroughDefinition = new ArrayList()
		currentNestedSchemas = new ArrayList()
		root = resource.allContents.filter(Schema).next
		var rootname = root.title !== null ?  root.title.replace(" ", "").replace(".", "").toFirstUpper : "root"
		objectList.add(new CustomModel(root, rootname))
		root.properties.recursiveObjectsFinder(rootname)
		root.definitions.recursiveObjectsFinder(rootname)
		modelGenerator = new ModelGenerator(objectList, root)
		rootBuilderGenerator = new RootBuilderGenerator(objectList, root)
		builderGenerator = new BuilderGenerator(objectList, root)
		objectList.forEach[model | {
			modelGenerator.generateModelFile(model, fsa)
			builderGenerator.generateBuilderFile(model, fsa)
			rootBuilderGenerator.generateBuilderFile(model, fsa)
		}]
		System.out.println(objectList.size)
	}
	
	def void recursiveObjectsFinder(List<NamedSchema> properties, String parentName){
		properties.forEach[property | {
			if(GeneratorUtils.realizeName(property.name).equals("channels")){
				System.out.println("rip")
			}
			var propSchema = property.schema;
			var schema = GeneratorUtils.isSchema(propSchema) ? (propSchema as Schema) : GeneratorUtils.findLocalReference(GeneratorUtils.realizeName((propSchema as Reference).uri),root)
			if(GeneratorUtils.isReference(propSchema)){
				var referenceeName = GeneratorUtils.getReferenceName(propSchema)
				if(walkedThroughDefinition.contains(referenceeName)){
					return
				}
			}
			
			var propName = GeneratorUtils.realizeName(property.name)
			if(schema !== null 
				&& !GeneratorUtils.realizeName(property.name).toLowerCase.equals(parentName.toLowerCase)
				&& !walkedThroughDefinition.contains(propName)
			){
				if(GeneratorUtils.isReference(propSchema)){
					val cm = new CustomModel(schema, GeneratorUtils.getReferenceName(propSchema))
					cm.parentName = parentName;
					objectList.add(cm)
					walkedThroughDefinition.add(GeneratorUtils.getReferenceName(propSchema))
					if(GeneratorUtils.isObject(schema)){
						schema.properties.recursiveObjectsFinder(GeneratorUtils.getReferenceName(propSchema))
					}
				}else if(GeneratorUtils.isObject(schema) && schema.propertyNames === null){
					val cm = new CustomModel(schema, propName)
					cm.parentName = parentName;
					objectList.add(cm)
					walkedThroughDefinition.add(propName)
					schema.properties.recursiveObjectsFinder(propName)
				}
				if(schema.anyOfs !== null && !schema.anyOfs.empty){
					val cm = new CustomModel(schema, propName)
					cm.parentName = parentName;
					objectList.add(cm)
					walkedThroughDefinition.add(GeneratorUtils.realizeName(property.name))
					schema.anyOfs.complexityObjectsFinder(propName)
				}
				if(schema.oneOfs !== null && !schema.oneOfs.empty){
					val cm = new CustomModel(schema, propName)
					cm.parentName = parentName;
					objectList.add(cm)
					walkedThroughDefinition.add(GeneratorUtils.realizeName(property.name))
					schema.oneOfs.complexityObjectsFinder(propName)
				}
				if(schema.allOfs !== null && !schema.allOfs.empty){
					val cm = new CustomModel(schema, propName)
					cm.parentName = parentName;
					objectList.add(cm)
					walkedThroughDefinition.add(GeneratorUtils.realizeName(property.name))
					schema.allOfs.complexityObjectsFinder(propName)
				}
			}
		}]
	}
	def void complexityObjectsFinder(List<AbstractSchema> schemas, String parentName){
		schemas.forEach[abstractSchema | {
			var schema = GeneratorUtils.isSchema(abstractSchema) ? (abstractSchema as Schema) : GeneratorUtils.findLocalReference(GeneratorUtils.realizeName((abstractSchema as Reference).uri),root)
			if(schema !== null 
				&& !currentNestedSchemas.contains(abstractSchema)
			){
				currentNestedSchemas.add(abstractSchema)
				if(GeneratorUtils.isObject(schema)){
					schema.properties.recursiveObjectsFinder(parentName)
				}
				if(schema.anyOfs !== null && !schema.anyOfs.empty){
					schema.anyOfs.complexityObjectsFinder(parentName)
				}
				if(schema.oneOfs !== null && !schema.oneOfs.empty){
					schema.oneOfs.complexityObjectsFinder(parentName)
				}
				if(schema.allOfs !== null && !schema.allOfs.empty){
					schema.allOfs.complexityObjectsFinder(parentName)
				}
			}
		}]
	}
	
	
}
